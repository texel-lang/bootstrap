import {
   Assignment,
   BinaryExpression,
   BinaryNegate,
   BinaryOp,
   BooleanLiteral,
   Call,
   CharLiteral,
   DoubleLiteral,
   Expression,
   ExpressionStatement,
   FunctionDeclaration,
   Identifier,
   IfElseStatement,
   IntLiteral,
   isAssignment,
   isBinaryExpression,
   isBinaryNegate,
   isBooleanLiteral,
   isCall,
   isCharLiteral,
   isDoubleLiteral,
   isExpressionStatement,
   isIdentifier,
   isIfElseStatement,
   isIntLiteral,
   isLoopControlStatement,
   isLoopStatement,
   isMemberAccess,
   isReturnStatement,
   isStringLiteral,
   isStructLiteral,
   isVariableDeclaration,
   LoopControlStatement,
   LoopStatement,
   MemberAccess,
   ReturnStatement,
   Statement,
   StringLiteral,
   StructLiteral,
   TexelFile,
   VariableDeclaration,
} from "../Tree";
import { TypeCheckData } from "./CheckTypes";
import { CompilerData } from "./CompilerData";

export class OutputBuilder {
   private indentation: string = "";

   constructor(
      public data: CompilerData,
      public types: TypeCheckData,
      public file: TexelFile,
      public result: string,
   ) {

   }

   public increaseIndentation(): OutputBuilder {
      this.indentation += "  ";
      return this;
   }

   public decreaseIndentation(): OutputBuilder {
      if (this.indentation.length > 1) {
         this.indentation = this.indentation.slice(0, this.indentation.length - 2);
      } else {
         this.indentation = "";
      }
      return this;
   }

   public indent(): OutputBuilder {
      this.result += this.indentation;
      return this;
   }

   public newLine(): OutputBuilder {
      this.result += "\n";
      return this;
   }

   public semicolon(): OutputBuilder {
      this.result += ";";
      return this;
   }

   public comment(value: any): OutputBuilder {
      this.result += "/*";
      this.newLine();

      if (typeof value === "object") {
         this.result += JSON.stringify(value);
      } else if (["boolean", "number", "string"].includes(typeof value)) {
         this.result += value;
      } else {
         throw new TypeError(`Can't stringify and comment: ${ value }.`);
      }

      this.newLine();
      this.result += "*/";
      this.newLine();

      return this;
   }

   public plain(value: string): OutputBuilder {
      this.result += value;
      return this;
   }

   public commaSeparatedPlain(value: string[]): OutputBuilder {
      this.result += value.join(", ");
      return this;
   }
}

export function buildEcmaScript(
   data: CompilerData,
   types: TypeCheckData,
   file: TexelFile,
): string {
   const output: OutputBuilder = new OutputBuilder(data,
      types,
      file,
      "// Generated by the Texel bootstrap compiler \n\n",
   );

   file.functions.forEach(
      value => printFunction(output, value));

   output.plain("if (typeof main === \"function\") {")
   .increaseIndentation()
   .newLine()
   .indent()
   .plain("main()")
   .semicolon()
   .newLine()
   .decreaseIndentation()
   .indent()
   .plain("}")
   .newLine();

   return output.result;
}

function printFunction(
   output: OutputBuilder,
   fn: FunctionDeclaration,
) {
   output.comment(`Function: ${ fn.name }`)
   .plain("function ")
   .plain(fn.name)
   .plain("(")
   .commaSeparatedPlain(fn.parameters.map(
      it => it.name))
   .plain(") {")
   .increaseIndentation()
   .newLine();

   fn.statements.forEach(
      it => {
         output.indent();
         printStatement(output, it);
         output.newLine();
      });

   output.decreaseIndentation().indent().plain("}").newLine().newLine();

   // structs can be genarated via literals and then use `|| default` for default values;
}

function printStatement(
   output: OutputBuilder,
   stmt: Statement,
) {
   if (isVariableDeclaration(stmt)) {
      printVariableDeclaration(output, stmt);
   } else if (isExpressionStatement(stmt)) {
      printExpressionStatement(output, stmt);
   } else if (isLoopStatement(stmt)) {
      printLoopStatement(output, stmt);
   } else if (isLoopControlStatement(stmt)) {
      printLoopControlStatement(output, stmt);
   } else if (isIfElseStatement(stmt)) {
      printIfElseStatement(output, stmt);
   } else if (isReturnStatement(stmt)) {
      printReturnStatement(output, stmt);
   } else {
      throw new Error(`Unknown statement: ${ JSON.stringify(stmt) }`);
   }
}

function printVariableDeclaration(
   output: OutputBuilder,
   stmt: VariableDeclaration,
) {
   output.plain("let ").plain(stmt.name).plain(" = ");
   if (stmt.expression !== undefined) {
      printExpression(output, stmt.expression);
   }
   output.semicolon();
}

function printExpressionStatement(
   output: OutputBuilder,
   stmt: ExpressionStatement,
) {
   printExpression(output, stmt.expression);
   output.semicolon();
}

function printLoopStatement(
   output: OutputBuilder,
   stmt: LoopStatement,
) {
   output.plain("while(");
   printExpression(output, stmt.expression);
   output
   .plain(") {")
   .increaseIndentation()
   .newLine();

   stmt.statements.forEach(
      value => {
         output.indent();
         printStatement(output, value);
         output.newLine();
      });

   output.decreaseIndentation().indent().plain("}");
}

function printLoopControlStatement(
   output: OutputBuilder,
   stmt: LoopControlStatement,
) {
   output.plain(stmt.isContinue ? "continue;" : "").plain(stmt.isBreak ? "break;" : "");
}

function printIfElseStatement(
   output: OutputBuilder,
   stmt: IfElseStatement,
) {
   output.plain("if (");
   printExpression(output, stmt.expression);
   output.plain(") {").increaseIndentation().newLine();
   stmt.statements.forEach(
      it => {
         output.indent();
         printStatement(output, it);
         output.newLine();
      });

   output.decreaseIndentation().indent().plain("}");

   stmt.elseIfs.forEach(
      elseIf => {
         output.plain(" else if (");
         printExpression(output, elseIf.expression);
         output.plain(") {").increaseIndentation().newLine();
         elseIf.statements.forEach(
            it => {
               output.indent();
               printStatement(output, it);
               output.newLine();
            });
         output.decreaseIndentation().indent().plain("}");
      });

   output.plain(" else {").increaseIndentation().newLine();
   stmt.elseStatements.forEach(
      it => {
         output.indent();
         printStatement(output, it);
         output.newLine();
      });
   output.decreaseIndentation().indent().plain("}");
}

function printReturnStatement(
   output: OutputBuilder,
   stmt: ReturnStatement,
) {
   output.plain("return");
   if (stmt.expression !== undefined) {
      output.plain(" ");
      printExpression(output, stmt.expression);
   }
   output.semicolon();
}

function printExpression(
   output: OutputBuilder,
   expr: Expression,
) {
   if (isAssignment(expr)) {
      printAssignment(output, expr);
   } else if (isBinaryExpression(expr)) {
      printBinary(output, expr);
   } else if (isBinaryNegate(expr)) {
      printBinaryNegate(output, expr);
   } else if (isCall(expr)) {
      printCall(output, expr);
   } else if (isMemberAccess(expr)) {
      printMemberAccess(output, expr);
   } else if (isBooleanLiteral(expr)) {
      printBoolean(output, expr);
   } else if (isStringLiteral(expr)) {
      printString(output, expr);
   } else if (isCharLiteral(expr)) {
      printChar(output, expr);
   } else if (isIntLiteral(expr)) {
      printInt(output, expr);
   } else if (isDoubleLiteral(expr)) {
      printDouble(output, expr);
   } else if (isStructLiteral(expr)) {
      printStruct(output, expr);
   } else if (isIdentifier(expr)) {
      printIdentifier(output, expr);
   }
}

function printAssignment(
   output: OutputBuilder,
   expr: Assignment,
) {
   // Not supporting nested assignment yet
   printExpression(output, expr.name);
   output.plain(" = ");
   printExpression(output, expr.expression);
}

function printBinary(
   output: OutputBuilder,
   expr: BinaryExpression,
) {
   output.plain("(");
   printExpression(output, expr.left);
   switch (expr.op) {
      case BinaryOp.ADD:
         output.plain(" + ");
         break;
      case BinaryOp.SUBTRACT:
         output.plain(" - ");
         break;
      case BinaryOp.MULTIPLY:
         output.plain(" * ");
         break;
      case BinaryOp.DIVIDE:
         output.plain(" / ");
         break;
      case BinaryOp.LOGIC_OR:
         output.plain(" || ");
         break;
      case BinaryOp.LOGIC_AND:
         output.plain(" && ");
         break;
      case BinaryOp.LOGIC_EQUAL:
         output.plain(" === ");
         break;
      case BinaryOp.LOGIC_NOT_EQUAL:
         output.plain(" != ");
         break;
      case BinaryOp.GREATER:
         output.plain(" > ");
         break;
      case BinaryOp.GREATER_EQUAL:
         output.plain(" >= ");
         break;
      case BinaryOp.SMALLER:
         output.plain(" < ");
         break;
      case BinaryOp.SMALLER_EQUAL:
         output.plain(" <= ");
         break;
   }

   printExpression(output, expr.right);
   output.plain(")");
}

function printBinaryNegate(
   output: OutputBuilder,
   expr: BinaryNegate,
) {
   output.plain("(!");
   printExpression(output, expr.expression);
   output.plain(")");
}

function printCall(
   output: OutputBuilder,
   expr: Call,
) {
   output.plain(expr.name).plain("(");
   expr.arguments.forEach((
      value,
      index,
   ) => {
      printExpression(output, value);
      if (index !== expr.arguments.length - 1) {
         output.plain(", ");
      }
   });
   output.plain(")");
}

function printMemberAccess(
   output: OutputBuilder,
   expr: MemberAccess,
) {
   if (isIdentifier(expr.expression)) {
      output.plain(expr.expression.identifier);
   } else if (isCall(expr.expression)) {
      printCall(output, expr.expression);
   } else {
      output.plain("(");
      printExpression(output, expr.expression);
      output.plain(")");
   }

   output.plain(".").plain(expr.member);
}

function printBoolean(
   output: OutputBuilder,
   expr: BooleanLiteral,
) {
   output.plain(expr.value ? "true" : "false");
}

function printString(
   output: OutputBuilder,
   expr: StringLiteral,
) {
   output.plain("\"").plain(expr.value).plain("\"");
}

function printChar(
   output: OutputBuilder,
   expr: CharLiteral,
) {
   printString(output, expr);
}

function printInt(
   output: OutputBuilder,
   expr: IntLiteral,
) {
   output.plain(expr.value.toString(10));
}

function printDouble(
   output: OutputBuilder,
   expr: DoubleLiteral,
) {
   output.plain(expr.value.toString(10));
}

function printStruct(
   output: OutputBuilder,
   expr: StructLiteral,
) {
   output.plain("{").newLine().increaseIndentation();
   // TODO : Default values.

   expr.assignments.forEach(
      value => {
         output.indent().plain(value.name).plain(": ");
         printExpression(output, value.value);
         output.plain(",").newLine();
      });

   output.decreaseIndentation().indent().plain("}");
}

function printIdentifier(
   output: OutputBuilder,
   expr: Identifier,
) {
   output.plain(expr.identifier);
}
